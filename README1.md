# Interview

## 2,jvm调优

### 1,java内存模型，新生代老年代算法

### 2,新生代老年代属于堆还是栈，还知道哪些gc算法

### 3,创建大对象也是在新生代分配吗

### 4,新生代的算法

### 5,说说minor gc,minor gc触发条件

### 6,老年代用了什么算法

### 7,说说标记整理算法

### 8,full gc是否真正回收了废弃对象

### 9,有哪些gc策略。你觉得你的项目中如果需要jvm调优你会注重哪个分带的调优，或者说更注重哪种gc调优，为什么，具体怎么做


## 7,你对线程安不安全怎么理解（关键词:全局变量、JVM运行时数据区、可见性、原子性、锁

[如何理解线程安全](https://ddmcc.space/2019/06/24/how-to-understand-thread-safety/)

| 特性    | volatile | synchronized  | Lock     |
|---------|:-------:|:-------------:|:--------:|
| 可见性  | 可以保障  | 可以保障       | 可以保障 |
| 原子性  | 无法保障  | 可以保障       | 可以保障 |
| 有序性  | 部分保障  | 无法保障       | 无法保障 |

#### 总结 
线程安全是因为全局变量及静态变量引起的，如果有全局变量或静态变量则要解决可见性，有序性，有序性问题。


## 17,哪些字段适合建立索引，mysql索引底层数据结构了解吗?（*）
- 频繁作为查询条件的字段应该创建索引
- 查询中与其他表有关联的字段，例如外键关系
- 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件
- 查询中排序的字段创建索引将大大提高排序的速度
- 经常增删改的表不适合创建索引
- 数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引

## 18,索引什么情况下会失效，联合索引abc只用了a字段，索引是否会生效

- 左模糊索引会失效，右模糊不会
- where语句中使用不等于 <> 和 !=
- 使用not in
- 使用 or，但是没有把or中所有字段加上索引
- 条件中对字段进行表达式操作(+,-等等)
- 使用is not null 判断,is null 则会使用。
- 对于多列索引，不是使用的第一部分，则不会使用索引
- 数据库字段为字符串，条件不加引号，不会使用索引

2，联合索引abc只用了a字段，索引会生效

## 24,sleep和wait区别
- sleep是Thread 类的静态本地方法，wait则是Object类的本地方法
- 当线程处于上锁时，sleep()方法不会释放对象锁，即睡眠时也持有对象锁。只会让出CPU执行时间片，并不会释放同步资源锁，
wait()方法释放对象锁。
- sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用
- sleep()必须捕获异常，wait()方法、notify()方法和notiftAll()方法不需要捕获异常
- sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起）

## 28,synchronize实现原理


## 29,synchronize与lock区别

- 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
- synchronized无法判断是否获取**锁的状态**，Lock可以判断是否获取到锁；
- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在**finally中手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁；
- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，**而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了**；
- synchronized的锁**可重入、不可中断、非公平**，而Lock锁**可重入、可判断、可公平**（两者皆可）
- Lock锁适合**大量同步的代码的同步问题**，synchronized锁**适合代码少量的同步问题**。

## 30,还知道哪些锁，说说自旋锁
- 可重入锁(ReentrantLock)，再一个锁中可以获得另一个锁。
- 读写锁(ReadWriteLock)，其读锁是共享锁，其写锁是独享锁。
- 自旋锁(CAS)

## 31,死锁产生原因
只有满足 **互斥,不可剥夺,请求与保持,循环等待** 才有可能发生死锁现象。

[死锁产生的条件及解决](https://ddmcc.space/2019/06/26/deadlock-conditions/)

## 35,http和https区别
- https协议需要申请证书，一般免费证书较少，因而需要一定费用。

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 36,get和post区别
- get请求有长度的限制,而post请求没有长度的限制
- get请求的数据是以key/value的形式跟上url的后面,而post请求是以附件的形式发送过去的
- get请求的数据会在地址栏中明文的显示,而且还会保存在浏览器的历史记录,而post请求不会，所以post的安全性更高


## 46,能调用另一个类的私有方法吗，怎么做?
可以
- 通过反射，获得私有方法，设置可访问，执行invoke
- 在类的内部创建一个public方法调用私有方法，然后去调用public方法

## 47,如果线程池执行shutdown或shutdownNow，线程池中线程会中断吗，会出现什么异常，catch处理中该写些什么？（*）
shutdown只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断。
而shutdownNow则是将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回。


## 49,CAS操作可能会存在什么问题？
#### ABA
问题描述：线程t1将它的值从A变为B，再从B变为A。同时有线程t2要将值从A变为C。但CAS检查的时候会发现没有改变，但是实质上它已经发生了改变 。可能会造成数据的缺失。

解决方法：CAS还是类似于乐观锁，同数据乐观锁的方式给它加一个版本号或者时间戳，如AtomicStampedReference

#### 自旋消耗资源
问题描述：多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。

解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来

#### 多变量共享一致性问题
解决方法： CAS操作是针对一个变量的，如果对多个变量操作，1. 可以加锁来解决。2 .封装成对象类解决。

## 51,TreeMap中compartor用了什么设计模式
Strategy（策略模式）

## 53,注解实现原理

## 55,SpringMVC Controller中定义全局HashMap，它是否是线程安全的，为什么?
SpringMVC Controller默认是单例类，也可以设置成非单例。

如果是非单例的每次有请求都会是新的实例，所以它是线程安全的。

在单例多线程的情况下，如果只对变量进行读，而没有写的操作，那么可以认为线程是安全的。
如果有写的操作，那么如果不能保证线程操作的可见性，原子性，有序性。那么线程就是非安全。


## 62,分库分表按什么规则分,如果查询字段不是分库分表的规则字段，怎么办
#### 垂直分
- 垂直分库，基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。
- 垂直分表，拆分是基于关系型数据库中的"列"进行的。通常情况，某个表中的字段比较多，可以新建立一张表，将不经常使用或者长度较大的字段拆分出去。

#### 水平分
- 水平分表，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。
最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。
- 水平分库分表，水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据库中。这也是很多大型互联网公司所选择的做法

#### 分区
- RANGE分区，字段值的范围进行分区
- HASH分区
- KEY分区

多维度查询


## 70,序列化作用
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化（将对象转换成二进制）。
可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间，序列化是为了解决在对对象流进行读写操作时所引发的问题。
把对象转换为字节序列的过程称为对象的序列化，把字节序列恢复为对象的过程称为对象的反序列化。


## 79,Arraylist扩容怎么实现的，为什么采用复制数组的方式而不是往后直接添加数据
Arraylist扩容是复制数组。

数组的地址是连续的，可能原来的数组后面的内存地址已经被使用了。


## 89,索引的优缺点?
#### 优点
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

#### 缺点
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，
那么需要的空间就会更大。 
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
