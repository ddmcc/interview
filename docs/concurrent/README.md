
#### 什么是线程和进程？

- 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，
当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程

- 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，
但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程


#### 线程有几种创建方式？

创建线程有三种方式： **继承Thread** 、 **实现Runnable接口** 、 **实现Callable接口结合Future**


- **继承Thread，重写 run 方法**

```java
class MyThread extends Thread {
    
    @Override
    public void run() {
  
    }
    
}
```

- **实现Runnable接口，重写 run 方法**

```java
class MyRunable implements Runnable {
    
    @Override
    public void run() {
        
    }
}
```


- 实现Callable接口结合FutureTask


创建一个实现了 Callable<T> 接口的类，并实现 `call` 方法

```java
class MyFutureTask implements Callable<String> {
    
    @Override
    public String call() throws Exception {
   
    }
}
```

通过 `Callable` 实例创建 `FutureTask` ，然后通过 `FutureTask` 实例创建并启动线程


```java
public static void main(String[]args) {
    // 创建异步任务
    FutureTask<String> futureTask = new FutureTask<>(new MyFutureTask());
    // 启动线程
    new Thread(futureTask).start();
    String result = futureTask.get();
```


#### 说说线程的生命周期和状态？

线程创建之后处于 **NEW 新建状态** ，调用 `start()` 方法后开始运行，线程这时候处于 **READY 就绪状态**。就绪状态的线程获得了 `CPU` 时间片（timeslice）后就处于 **RUNNING 运行状态**。
在执行过程中，当线程执行 `wait()` 方法之后，线程进入 **WAITING 等待状态**。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING 超时等待状态** 相当于在等待状态的基础上增加了超时限制，比如通过 `sleep(long millis)` 方法或 `wait(long millis)`方法可以将 `Java` 线程置于 `TIME_WAITING` 状态。
当超时时间到达后 `Java` 线程将会返回到 **READY 就绪状态**。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞） 状态**。线程在执行 `Runnable` 的 `run()` 方法之后将会进入到 **TERMINATED 终止状态**


#### 说说sleep方法和wai方法区别和共同点？

- 两者最主要的区别在于：**sleep() 方法没有释放锁，而 wait() 方法释放了锁** 。

- 两者都可以暂停线程的执行。

- wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。

- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒


#### 为什么我们不能直接调用run方法？


new 一个 Thread，线程进入了新建状态。调用 `start()` 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 
但是，直接执行 `run()` 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**

#### 为什么要使用多线程呢？

- 1. **提高程序的响应速度：** 在单线程程序中，如果一个任务需要执行很长时间，整个程序就会被阻塞。而在多线程程序中，每个线程可以执行不同的任务，可以并发执行，从而提高了程序的响应速度。

- 2. **充分利用 `CPU` 资源：** 多线程程序可以在多核 CPU 上并发执行，充分利用 `CPU` 资源，提高程序的性能

- 3. **提高系统资源利用率：** 多线程程序可以避免因等待某个操作完成而浪费系统资源，例如等待输入/输出完成等操作。

- 4. **改善程序结构：** 使用多线程可以将复杂的程序分解成多个简单的任务，使程序结构更加清晰、易于维护。

- 5. **提高用户体验：** 在一些需要进行耗时操作的应用中，例如图像处理、视频编辑等应用中，使用多线程可以让用户获得更好的体验，避免用户等待时间过长。

总之，使用多线程可以提高程序的性能和响应速度，充分利用系统资源，提高用户体验，改善程序结构，是编写高效程序的重要手段之一


#### 使用多线程可能带来什么问题？

并发编程的目的就是为了能提高程序的执行效率、提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等


#### 什么是线程死锁？如何避免死锁？

>什么是死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止

**死锁必须具备以下四个条件：**

- **互斥条件：** 该资源任意一个时刻只由一个线程占用。

- **请求与保持条件：** 一个进程因请求资源而阻塞时，对已获得的资源保持不放。

- **不可剥夺条件:** 线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

- **循环等待条件:** 若干进程之间形成一种头尾相接的循环等待资源关系


**如何预防死锁？** 破坏死锁的产生的必要条件即可：

- `坏请求与保持条件：` 一次性申请所有的资源。

- `破坏不剥夺条件：` 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

- `破坏循环等待条件：` 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。


#### 说说并发与并行的区别？

- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)

- **并行：** 单位时间内，多个任务同时执行


#### 什么是上下文切换？

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**


#### 并发编程三大特性


- **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。

- **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。

- **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。
