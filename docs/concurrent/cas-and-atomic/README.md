### CAS和Atomic原子类


#### 了解CAS吗

**`CAS`** ：就是比较并交换，其作用是让 `CPU`比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是 `CAS` 是原子性的操作(读和写两者同时具有原子性)
`Java` 是在 `Unsafe` 类实现 `CAS` 的操作，`Java` 并没有在 `Unsafe` 类直接实现 `CAS` 的操作，**而是通过JDI本地调用C/C++语言来实现CAS操作的**


#### Atomic原子类有什么用？

**原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”**，主要作用是解决多线程下的线程不安全的问题（比如i++问题）。

原子类的作用和锁有类似之处，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：

- **粒度更细** ：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。（锁通常是一段代码）

- **效率更高** ：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 `CAS` 操作，不会阻塞线程


#### 能不能简单介绍一下AtomicInteger类的原理

`AtomicInteger` 类主要利用 `CAS (compare and swap)` + `volatile` 和 `native` 方法来保证原子操作，从而避免 `synchronized` 的高开销，执行效率大为提升。

`CAS` 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。`UnSafe` 类的 `objectFieldOffset()` 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存偏移量，返回值是 `valueOffset` 。另外 `value` 是一个 `volatile` 变量，在内存中可见，因此 `JVM` 可以保证任何时刻任何线程总能拿到该变量的最新值

> valueOffset 是变量值在内存的偏移量，修改时直接根据内存偏移量拿到当前值，再比较，通过后直接更改内存中的值；volatile 保证了该变量的可见性，使操作具有load语义


#### CAS会带来哪些问题？能不能讲讲

CAS虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面
    
- **`ABA问题`** ： 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A->B->A就变成了1A->2B->3A，`AtomicStampedReference` 带有版本号的原子类

- **`循环时间长开销大`** ： 如果CAS操作失败，就需要循环进行CAS操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。**限制自旋次数，防止进入死循环**

- **`只能保证一个共享变量的原子操作`** 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行CAS操作

