### volatile关键字

#### 讲一下JMM

在 `JDK1.2` 之前，`Java` 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如cpu的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成 **数据的不一致**

这时就需要特殊指令，称为 `内存屏障`，以刷新本地缓存或使本地处理器缓存无效，以查看其他处理器的写入或使该处理器的写入对其它处理器可见。这些内存屏障通常在采取锁定和解锁操作时执行


#### happens-before是什么？

核心是 **前一个操作的结果对后续操作是可见的，这是 JMM 向程序员做出的保证**。但再不改变程序执行结果的前提下，编译器和处理器会对代码进行优化。也就是说两个操作之间存在 `happens-before` 规则 Java 并不一定按照规则定义的顺序来执行。 这么做的原因是因为我们程序员并不关心两个操作是否被重排序，只要保证程序执行时语义不能改变就好了

**1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前**

**2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法**


- **`程序次序规则`：** 一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。

- **`锁定规则`：** 这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。

- **`volatile变量规则`：** 这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。

- **`传递规则`：** 提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C

- **`线程启动规则`：** 假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。

- **`线程终结规则`：** 假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见


#### volatile关键字的作用？

>在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致


根据 `happens-before` 规则：如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的

- **保证变量的可见性：变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取**

- **volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行**


#### 说说synchronized关键字和volatile关键字的区别？

- **原子性** : `synchronized` 可以保证代码片段的原子性。

- **可见性**

可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。

除了 `volatile` 关键字之外，`final` 和 `synchronized` 也能实现可见性。

`synchronized`的原理是，在执行完，进入`unlock` 之前，必须将共享变量同步到主内存中。

`final` 修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的


- **有序性** 

在Java中，可以使用 `synchronized` 或者 `volatile` 保证多线程之间操作的有序性。实现原理有些区别：

`volatile` 关键字是使用内存屏障达到禁止指令重排序，以保证有序性。

`synchronized` 的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的
