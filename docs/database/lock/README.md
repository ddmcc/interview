### 锁

#### InnoDB引擎的行锁是怎么实现的？

InnoDB 通过给索引项加锁来实现行锁，如果没有索引，则通过隐藏的聚簇索引来对记录加锁。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样


#### InnoDB存储引擎的锁的算法

`InnoDB` 存储引擎有3种行锁的算法，分别是：

 - `Record Lock`: 单个记录上的锁
 
- `Gap Lock`: 间隙锁，锁定一个范围，但不包括本记录

- `Next-Key Lock`: **Gap Lock + Record Lock**，锁定一个范围，并且锁定记录本身

`InnoDB ` 对于行的查询都是默认采用 `Next-Key lock` 算法。当条件索引是唯一索引时，`InnoDB` 存储引擎会进行优化，将其降级为 `Record Lock`，即锁住索引本身 ，而不是范围，从而提高并发性。若是通过辅助索引查询，不但会给辅助索引加锁，还会为聚集索引上锁。对于辅助索引加 `Next-Key Lock`，而聚集索引因为是唯一的，所以只会加 `Record Lock`

对于没有显示创建索引的表，则会对 `rowId` 的聚集索引来加锁。如果操作未使用索引查询，那么会对表中所有记录加锁，实际效果和表锁一样


#### 数据库的乐观锁和悲观锁是什么？怎么实现的？

- `悲观锁`

在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

在悲观锁的情况下，为了保证事务的隔离性，就需要 **一致性锁定读**。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据

- `乐观锁(一致性非锁定读)`

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性

而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据


#### 什么是死锁？怎么解决？
