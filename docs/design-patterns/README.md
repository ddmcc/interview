
## 设计模式

#### 说说设计模式6大原则

- **单一职责原则**

`核心思想`：应该有且仅有一个原因引起类的变更

`问题描述`：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作

`好处`：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。


- **开闭原则**

>定义：类、模块、函数等应该是可以拓展的，但是不可修改。或者说修改也不能影响到现有的功能

`核心思想`：需要变化时，应该尽量通过拓展的方式来实现变化，而不是通过修改已有代码来实现


- **里氏替换原则**

>定义：所有引用基类的地方必须能透明地使用其子类的对象


`核心思想`：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。

`通俗来讲`：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任

采用里氏替换原则的好处可以让继承的 `好处` 发挥最大的作用（如：减少创建类的工作量，提供代码重用等），
并减少继承的 `“弊”` 带来的诸多麻烦（如：继承增强了耦合性，当需要对父类的代码进行修改时，必须考虑到对子类产生的影响）。这就要求：

- 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法

- 子类中可以增加自己特有的方法

- 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松

- 当子类的方法实现父类的（抽象）方法时，方法的后置条件（即方法的返回值）要比父类更严格


**简单的来说就是尽量不修改父类继承而来的方法，如果要修改也要不影响父类和其它类**


- **依赖倒置原则**

`核心思想`：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象

`说明`：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类

`通俗来讲`：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合

`问题描述`：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

`解决方案`：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率


- **接口隔离原则**

`核心思想`：类间的依赖关系应该建立在最小的接口上

`通俗来讲`：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用

    接口尽量小，但是要有限度 对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
    
    提高内聚，减少对外交互 使接口用最少的方法去完成最多的事情
    
    为依赖接口的类定制服务 只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系


- **迪米特原则**

`核心思想`：类间解耦

`通俗来讲`： 一个类应该对自己需要耦合或者调用的类知道越少越好。软件编程的总的原则：高内聚，低耦合

    一个处于松耦合中的类一旦被修改，则不会对关联的类造成太大的波及。
    
    在类的机构设计上， 每一个类都应当尽量降低其成员变量和成员函数的访问权限
    
    在对其他类的引用上， 一个类对其他对象的引用应当降到最低


**一句话总结：**

`单一职责原则` 告诉我们实现类要职责单一；`里氏替换原则`告诉我们不要破坏继承体系；`依赖倒置原则` 告诉我们要面向接口编程；`接口隔离原则` 告诉我们在设计接口的时候要精简单一；`迪米特法则` 告诉我们要降低耦合。而`开闭原则是总纲`，他告诉我们要对扩展开放，对修改关闭



#### 代理模式和桥接模式的异同点？


`代理`、`桥接`、`装饰器`、`适配器`，这 4 种模式是比较常用的 **结构型设计模式**。它们的代码结构非常相似。笼统来说，它们都可以称为 `Wrapper` 模式，也就是通过 `Wrapper` 类二次封装原始类。


`代理模式`：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，通过 `组合的方式` 来控制访问和增强

`桥接模式`：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变

`装饰器模式`：装饰者模式在不改变原始类接口的情况下，`通过继承的方式`，对原始类功能进行增强，并且支持多个装饰器的嵌套使用

`适配器模式`：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口



#### 有几种单例的实现方式？以及它们的优缺点？

1）**饿汉式单例模式**

是最简单实现单例的方式，~~在类加载的时候就已经实现单例模式对象的生成，如果出现该单例对象占用内存很大但是从来未被调用的情况，该方式就会造成资源的浪费~~


2）**懒汉单例模式（线程不安全）**

它的优点是在第一次访问的时候才会被创建，避免了创建了没有使用而浪费资源的问题。但是每次访问都需要判断是否创建，也会影响性能。而且在 `多线程` 的情况下，它 并不是线程安全的。有可能会产生不同的对象


3）**懒汉同步式**

确保了每次只有一个线程进入方法，解决了线程安全的问题。但因为是同步方法，所以会很影响性能。而且我们只需要确保第一次访问的时候不被重复创建实例， 在第一次创建之后，同步方法就成了累赘了


4）**双重检查加锁**

这种方式是对前一种实现方式的改进，既保证了线程安全，也避免了性能影响，但是需要注意的是单例对象的引用需要用 `volatile` 关键字修饰，防止指令重排序，避免产生未初始化完全的对象


5）**静态内部类**

`优点`： 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化instance，故而不占内存。即当SingletonPattenTest第一次被加载时， 并不需要去加载SingleTonHoler，只有当getInstance()方法第一次被调用时，才会加载SingleTonHoler类并初始化instance，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。

`缺点`：

- 需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其 Class 对象还是会被创建，而且是属于方法区的对象

- 创建的单例，一旦在后期被销毁，不能重新创建


6）**注册表式**

用一个map来作为存储实例的载体，本质还是双重检查加锁的方式


7）**枚举式**

- 避免反射攻击的问题

- 避免线程安全问题。枚举类所有属性都会被声明称static类型，它是在类加载的时候初始化的，而类的加载和初始化过程都是线程安全的

- 避免序列化问题， 任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。枚举序列化的时候仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象



#### 有几种动态代理的方式及它们实现的原理

动态代理主要有 **JDK 动态代理、CGLIB 动态代理**，- todo

