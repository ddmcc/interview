### Map


#### HashMap和Hashtable的区别

- **线程是否安全：**  `HashMap` 是非线程安全的，`HashTable` 是线程安全的,因为 `HashTable` 内部的方法基本都经过 `synchronized` 修饰

- **效率：** 因为线程安全的问题，`HashMap` 要比 `HashTable` 效率高一点

- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 `null` 的 `key` 和 `value`，但 `null` 作为键只能有一个，`null` 作为值可以有多个；`HashTable` 不允许有 `null` 键和 `null` 值，否则会抛出 `NullPointerException`

- **初始容量大小和每次扩充容量大小的不同 ：** 
   - ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。
    `HashMap` 默认的初始化大小为 `16`。之后每次扩充，容量变为原来的 2 倍。

   - ② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 `HashMap` 会将其扩充最接近的 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小

- **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。
`Hashtable` 没有这样的机制。


#### HashMap底层数据结构

-  **`JDK1.8 之前`**

**JDK1.8 之前** `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。`HashMap` 通过 `key` 的 `hashCode` 经过扰动函数处理过后得到 `hash` 值，
然后通过 **(n - 1) & hash** 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 `key` 是否相同，
如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

>**所谓 “拉链法” 就是：** 将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可
>
>
>**所谓扰动函数指的就是** `HashMap` 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说使用扰动函数之后可以减少碰撞


- **`JDK1.8 之后`**

相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间，当红黑树元素小于 6 时会转为链表

> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构


#### HashMap的长度为什么是2的幂次方？

- 为了减少哈希碰撞，`HashMap` 通过 `key` 的 `hashCode` 经过扰动函数处理过后得到 `hash` 值，**但是 `hash` 值太大，所以需要取余运算来得到对应的数组下标**

- 在取余操作中，如果除数 `length` 为 2 的 幂次方，那么 `hash % length` = `hash & (length - 1)` ，**采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方** 


#### ConcurrentHashMap底层具体实现

- **`JDK1.7`**

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，
每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁，
`Segment` 实现了 `ReentrantLock`，所以 `Segment` 是一种可重入锁，扮演锁的角色。当一个线程占用其中一个段数据时，其他段的数据也能被其他线程访问


- **`JDK1.8`**

`ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 `CAS` 和 `synchronized` 来保证并发安全。数据结构跟 `HashMap1.8` 的结构类似，**数组+链表/红黑二叉树**。
`Java 8` 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）

`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发


#### ConcurrentHashMap和Hashtable的区别

- **`底层数据结构：`** 

   - `JDK1.7` 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，`JDK1.8` 采用的数据结构跟 `HashMap 1.8` 的结构一样，**数组+链表/红黑二叉树**。

   - `Hashtable` 和 `JDK1.8` 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 `HashTable` 的主体，链表则是主要为了解决哈希冲突而存在的；
   
- **`实现线程安全的方式（重要）：`**

   - 在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，
   就不会存在锁竞争，提高并发访问率；到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` **数组+链表/红黑树** 的数据结构来实现，并发控制使用 `synchronized` 和 `CAS` 来操作。
   （JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 `JDK1.8` 中还能看到 `Segment` 的数据结构，但是已经简化了属性，
   只是为了兼容旧版本；
   
   - **Hashtable(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低
