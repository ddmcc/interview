[Java虚拟机类加载过程](http://ddmcc.cn/2021/05/29/jvm-class-file-loading-process/)

### 类加载

#### 类的生命周期

一个类的生命周期包括加载、连接、初始化、使用、卸载5个阶段，其中连接阶段包括验证、准备、解析，具体如下：

![markdown](https://ddmcc-1255635056.file.myqcloud.com/2784440a-9233-4742-bf09-2da0d6e56250.png)


#### [类加载过程](http://ddmcc.cn/2021/05/29/jvm-class-file-loading-process/)

类加载过程包括：`加载（Loading）`、`连接（Linking）`、`初始化（Initialization）`3个阶段。其中连接过程又可以分为
验证（Verification）、准备（Preparation）、解析（Resolution）三个阶段

**加载阶段** 主要是通过类的全限定名来查找这个类的文件，将静态的类文件存储结构转化为运行时数据结构，并在内存中生成一个代表这个类的 java.lang.Class 对象，作为这个类的数据访问入口

这一步我们可以自定义类加载器去控制类文件的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建

**验证阶段** 的目的主要为了确保文件中的表示满足 静态语法或结构的约束 ，及安全性校验。主要包括文件格式验证、元数据验证、字节码验证、符号引用验证

**准备阶段** 主要为类或接口的静态字段分配内存，并将此类字段初始化为其默认值，**变量所使用的内存都将在 方法区 进行分配**。静态字段的显示初始化会在初始化阶段（Initialization）进行，而不是在准备阶段。并且准备阶段可以在加载后的任何时候进行，但必须在初始化之前完成

**解析阶段** 是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量

**初始化阶段** 就是执行初始化方法 `<clinit> ()` 方法的过程，是类加载的最后一步

#### 双亲委派加载机制

每一个类都有一个对应它的类加载器。系统中的 `ClassLoder` 在协同工作的时候会默认使用 `双亲委派模型` 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己的 `findClass()` 方法来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器

#### 如何实现一个自定义类加载器？

继承 `ClassLoader` 类，然后重写 `findClass` 方法

#### 如果不想用双亲委派模型怎么办？

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。
但是，如果想打破双亲委派模型则需要重写 loadClass() 方法

#### 双亲委派模型的好处？

可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），
也保证了 `Java` 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类
