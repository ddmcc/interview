#### Java8默认使用的垃圾收集器是什么?

`Java8` 版本的` Hotspot JVM`，默认情况下使用的是并行垃圾收集器（`Parallel GC`）。其他厂商提供的 `JDK8` 基本上也默认使用并行垃圾收集器

#### Java11的默认垃圾收集器是什么?

Java9之后，官方JDK默认使用的垃圾收集器是 `G1`

#### 什么是并行垃圾收集?

并行垃圾收集，是指使用多个GC worker 线程并行地执行垃圾收集，能充分利用多核CPU的能力，缩短垃圾收集的暂停时间

#### 什么是并发垃圾收集器?

并发垃圾收集器，是指在应用程序在正常执行时，有一部分GC任务，由GC线程在应用线程一起并发执行。例如 CMS/G1的各种并发阶段

#### 什么是G1增量式垃圾收集?

首先， G1的堆内存不再单纯划分为年轻代和老年代，而是划分为多个（通常是 2048个）可以存放对象的小块堆区域（smaller heap regions）。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。这样划分之后，使得 G1 不必每次都去回收整个堆空间，而是以增量的方式来进行处理： 每次只处理一部分内存块，称为此次 GC 的回收集（collection set）。下一次GC时在本次的基础上，再选定一定的区域来进行回收。增量式垃圾收集的好处是大大降低了单次GC暂停的时间

#### 垃圾回收器

- **`串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高`**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/2c00d3c5-88f7-444c-802a-8d44eb049453.png)

它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束

**新生代采用标记-复制算法，老年代采用标记-整理算法**

- **`并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间`**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/914abf09-dd8d-4e59-8637-189025c5e73b.png)

除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样

**新生代采用标记-复制算法，老年代采用标记-整理算法**

- **`吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制，JDK 1.8 默认使用的是 Parallel Scavenge + Parallel Old`**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/31ad7c3f-a04b-4f58-8fec-6a8613337779.png)


**新生代采用标记-复制算法，老年代采用标记-整理算法**

- **`并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的`**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/a2cd0a8d-aba1-4d98-9276-2f3acd59b69c.png)

它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。


主要优点：**并发收集**、**低停顿**。但是它有下面三个明显的缺点：

- 对 CPU 资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生


- **`G1 收集器`**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零

它最主要的特点是采用了基于区域的收集算法。
具体来说，G1 将堆空间划分为多个大小相等的区域，每个区域可以是年轻代，也可以是老年代。它采用增量标记、并发标记和并发清除等技术，以最小化垃圾收集的停顿时间。
在垃圾收集开始之前，G1 会根据实际情况动态地选择一个或多个区域进行垃圾回收，这些区域中包含的垃圾量最多，称为 G1 的 "目标区域"。在垃圾回收过程中，G1 会标记所有活动对象，并将它们从目标区域复制到其他区域中。同时，G1 还会清理目标区域中的垃圾，并将空闲空间释放回堆中。通过这种方式，G1 可以减少垃圾回收的停顿时间，并提高垃圾回收的效率。
总之，G1 垃圾回收器使用了基于区域的收集算法，以最小化停顿时间和提高垃圾回收效率
