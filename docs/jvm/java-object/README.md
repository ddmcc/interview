### Java对象


#### 对象的创建过程

![markdown](https://ddmcc-1255635056.file.myqcloud.com/629b9d68-355f-400b-8717-b3b47a12a0ae.png)

**Step1:类加载检查**

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程


**Step2:分配内存**

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来


**Step3:初始化零值**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值


**Step4:设置对象头**

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、锁等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式


**Step5:执行 init 方法**

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来



#### 对象内存的分配方式？

分配方式有 `指针碰撞` 和 `空闲列表` 两种

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![markdown](https://ddmcc-1255635056.file.myqcloud.com/a209c95b-510b-432f-aabf-e2740d9dd7ee.png)


**内存分配并发问题**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配


#### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：`对象头`、`实例数据`和`对齐填充`

**对象头** 包括两部分信息：

- 第一部分(mark word 8字节)用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）

- 另一部分是类型指针（class pointer 8字节），即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例

- length：**数组对象持有** 大小占用4字节

**实例数据** 部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容，包含所有成员变量

>boolean和byte：1字节
>
>short和char：2字节
>
>int和float：4字节
>
>long和double：8字节 
>
>reference：8字节

**对齐填充部分** 仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，
换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全


#### 对象的访问定位

对象的访问方式由虚拟机实现而定，目前主流的访问方式有 `使用句柄` 和 `直接指针` 两种：

1. **句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

![markdown](https://ddmcc-1255635056.file.myqcloud.com/6cc845e2-3e56-4108-88f1-4b956ea68217.png)

2. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址

![markdown](https://ddmcc-1255635056.file.myqcloud.com/03175ed3-cf2a-4aa6-81f7-637cbdf6ec33.png)


**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销**


#### Java中有哪些引用类型？

`强引用：` 发生 gc 的时候不会被回收

`软引用：` 有用但不是必须的对象，在发生内存溢出之前会被回收

`弱引用：` 有用但不是必须的对象，在下一次GC时会被回收

`虚引用（幽灵引用/幻影引用）：` 无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知
