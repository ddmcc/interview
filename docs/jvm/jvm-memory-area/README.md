### JVM内存区域

#### 运行时数据区

**1.8之前：**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/0ae211fc-8a32-4e8c-affa-9202418c4c05.png)


**1.8：**

![markdown](https://ddmcc-1255635056.file.myqcloud.com/06512b0c-a37c-4470-8940-05b256e1d1e7.png)


- **程序计数器：**

程序计数器只要有两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了

>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡


- **虚拟机栈：**

Java 虚拟机栈也是线程私有的，它的生命周期和线程相同。实际上，虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接（调用本地方法时，链接到本地方法栈的方法）、方法出口信息。

局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）


>**Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError：**
>
>`StackOverFlowError`： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误
>
>`OutOfMemoryError`： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常异常


- **本地方法栈：**

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务**

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误


- **堆：**

Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**

>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
>从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，
所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存**

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常被分为新生代、老年代和永久代。JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：

>`OutOfMemoryError`: `GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误
>
>`java.lang.OutOfMemoryError`: `Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误

- **方法区：**

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据


- **运行时常量池：**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误

>1. JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代
>2. JDK1.7 字符串常量池被从方法区拿到了堆中, **这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区**， 也就是 hotspot 中的永久代
>3. JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区,，只不过方法区的实现从永久代变成了元空间(Metaspace)


#### 程序计数器为什么是私有的？

程序计数器主要有下面两个作用：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

需要注意的是，如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 `Java` 代码时程序计数器记录的才是下一条指令的地址。

**所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置**


#### 虚拟机栈和本地方法栈为什么是私有的？

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

**所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的**


#### 深拷贝与浅拷贝

- 浅拷贝

**会为被复制的对象新开辟内存，但其所有属性的值会与原对象相同**

即如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型（堆内存地址），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象
>对于外层对象来说是深拷贝，对象里的引用类型变量来说是浅拷贝

- 深拷贝

深拷贝会拷贝所有的属性，如果属性是引用类型，则会为其新申请一块内存，并将内存地址赋值给属性


**Object的clone方法是深拷贝还是浅拷贝？如果要实现深拷贝怎么实现？**

Object的clone方法是浅拷贝，如果要实现深拷贝可以实现 **Cloneable** 接口，并重写 `Object.clone` 方法，自己实现深克隆。或者使用序列化/反序列化的方式进行深拷贝


**ArrayList集合、HashMap、Arrays.copyOf()方法等是深拷贝还是浅拷贝？** 

对于 `ArrayList` 来说，内部是用数组实现的，ArrayList对象本身和内部的数组对象都是新的对象，但其中的元素还是引用同一个地址，所以是浅拷贝

`HashMap` 也只是浅拷贝，键和值本身都不是克隆的

`Arrays.copyOf()` 返回的数组对象是新的对象，里面的元素也还是引用同一个地址，所以也是浅拷贝


#### 堆和栈的区别？

- `物理地址`

堆的物理地址分配对对象是不连续的。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

- `内存分别`

堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈

栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的

- `存放的内容`

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行

- `程序的可见度`

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同

- `异常`

当堆栈内存满时，Java运行时抛出 `Java.lang.StackOverFlowerError`，而如果堆内存满，则抛出 `Java.lang.OutOfMemoryError`:Java堆空间错误。



#### 方法是如何调用的？

Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是 `栈帧`，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。
栈帧中保存着一些执行方法的数据，如：局部变量表、操作数栈、动态链接、返回地址等

Java 方法有两种返回方式：

- return 语句
- 抛出异常

不管哪种返回方式都会导致栈帧被弹出


#### 方法区和永久代的关系

方法区是 Java 虚拟机规范中的定义，是一种规范，永久代是 HotSpot 的概念，是 HotSpot 对方法区的实现。，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法


#### 为什么要将永久代替换为元空间呢？

1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小

>当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace` 
>
>`-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制

2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了
