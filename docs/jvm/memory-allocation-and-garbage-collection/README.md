### 内存分配与垃圾回收

#### 对象内存分配机制

![markdown](https://ddmcc-1255635056.file.myqcloud.com/95d86b44-95d5-453c-917d-61106f3a5a67.png)

- `对象优先在 eden 区分配`

目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。针对新生代存活时间短对象

**大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1（分配到当时的FROM 区），
并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄达到15或达到动态晋升年龄阈值，就会被晋升到老年代中**


>"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到老年代中

- `大对象直接进入老年代`

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）

**为什么要这样呢？**

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率


- `长期存活的对象将进入老年代`

既然采用分代回收算法，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器

对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 可以通过参数 -XX:MaxTenuringThreshold 来设置 ）或者达到 `动态晋升年龄阀值`，就会被晋升到老年代中。


#### 动态计算晋升年龄阈值

遍历所有 `Survivor` 区域对象，按照 **年龄段从小到大对其所占用的大小进行累积** ，当加入某个年龄段后，累加的占用大小超过默认的 `-XX:TargetSurvivorRatio`（50%）时，取这个年龄和 `-XX:MaxTenuringThreshold` (15)中更小的一个值，作为新的晋升年龄阈值

```java
uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
  // survivor_capacity是survivor空间的内存大小
  // TargetSurvivorRatio survivor空间存活大小比例
  // desired_survivor_size 根据比例计算出期望存活对象内存总大小
  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
  size_t total = 0;
  uint age = 1;
  while (age < table_size) {
    // sizes数组是每个年龄段对象大小，根据年龄取出整个年龄段所占用的内存大小
    total += sizes[age];
    // 直到累计总内存大于期望的占用大小
    if (total > desired_survivor_size) break;
    age++;
  }
  // 用当前age和MaxTenuringThreshold 对比找出最小值作为结果
  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
    ...
}
```

#### 为什么设置新生代的年龄不能超过15？


在 `hotspots` 实现中，对象头的 `markword` 用了 `4bit` 去表示分代年龄，那么能表示的最大范围就是0-15（1111）。所以这也就是为什么设置新生代的年龄不能超过15，工作中可以通过 `-XX:MaxTenuringThreshold` 去调整，但是一般我们不会动


#### 垃圾回收算法

**标记-清除算法**

标记-清除分为“标记”和“清除”阶段：**首先标记出所有不需要回收的对象**，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。

这种垃圾收集算法会带来两个明显的问题：

- `效率问题`
- `空间问题（标记清除后会产生大量不连续的碎片）`


**标记-复制算法**

为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收


**标记-整理算法**

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内


**分代收集算法**

当前虚拟机的垃圾收集都采用分代收集算法，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集**



#### 为什么堆内存要分为新生代、老年代？

其实不分代完全可以，分代的好处就是优化GC性能。如果没有分代，所有的对象都在一块，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来

**所以这样进一步划分的目的是更好地回收内存，或者更快地分配内存**


#### 为什么要有Survivor区？

预筛选避免每进行一次 `Minor GC`，存活的对象就被送到老年代

Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，`Survivor` 的预筛选保证，只有经历一定次数 `Minor GC` 还能在新生代中存活的对象，才会被送到老年代

但是你可能会说不放`Survivor`，每次gc再判断对象的年龄行不行？这样的话每次都要扫描整个新生代，gc消耗的时间变长

**为什么要设置两个Survivor区**

设置两个Survivor区最大的好处就是解决了碎片化。新生代一般采用 `标记-复制` 的回收算法。但是复制算法必须要有另一块内存作为存放对象，来避免碎片化的发生


#### 新生代gc工作流程

![markdown](https://ddmcc-1255635056.file.myqcloud.com/9e289f4e-7e61-49bc-97a6-9d5ac4d0be6f.png)


HotSpot JVM把年轻代分为了三部分：`1个Eden区`和`2个Survivor区`（分别叫from和to）。默认比例为8（Eden）：1（一个survivor）

一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片

**在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中**


#### 如何判断对象是否死亡（两种方法）

- 引用计数法：

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的
    这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题
- 可达性分析算法：

基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的


>可作为 GC Roots 的对象包括下面几种:
>
>虚拟机栈(栈帧中的本地变量表)中引用的对象
>
>本地方法栈(Native 方法)中引用的对象
>
>方法区中类静态属性引用的对象
>
>方法区中常量引用的对象
>
>所有被同步锁持有的对象



#### MinorGc和FullGC有什么不同呢？

Partial GC：并不收集整个GC堆的模式

- Young GC：只收集young gen的GC
- Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
- Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式

Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。


#### 什么是空间分配担保机制？

在发生 `Minor GC` 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 `Minor GC` 可以确保是安全的。
如果不成立，则虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 `Minor GC`，尽管这次 `Minor GC` 是有风险的；如果小于，或者 `HandlePromotionFailure`设置不允许冒险，那这时也要改为进行一次 `Full GC` 。

>上面说的风险是什么呢？我们知道，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代
