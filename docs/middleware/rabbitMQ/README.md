#### rabbitMQ如何实现消息幂等？

- 每条消息生成唯一ID，消费端根据唯一ID判断是否已经消费过，如果消费过，则直接返回消费成功的ACK。

- 针对入库的业务操作可以通过数据库的唯一索引来实现避免重复业务数据入库；

- 针对修改数据类的操作，可以先判断数据是否已经是目标状态了，如果是目标状态，直接返回再进行更新。

- 针对并发的场景，我们需要给业务消费程序添加分布式锁，避免并发执行导致触发业务重复处理。


#### rabbitMQ出现消息堆积的情况怎么处理？

- 临时扩容，增加消费端，用硬件提升消费速度。
- 如果短时间内没有足够的服务器资源进行扩容，则将服务降级，关闭一些非核心业务，减少消息生产。
- 通过日志分析，监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量消息，中游消息队列存储层是否出现问题，下游消费速度是否变慢，就能确定哪个环节出了问题
- 根据排查解决异常部分。
- 等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器

>在队列数量没有变的情况下，单纯增加消费者数量是没有效果的。因为一个队列在同一时刻对于一个消费组来说是只会有一个消费者的，消费组中消费者再多也没意义。因此要么是在生产端把消息发往多个队列，达到并行消费的目的。要么是从该队列中取出消息，再将它分发个多个队列，从而达到并行消费的目的


#### RabbitMQ怎么保证消息不丢失？

主要分为3个阶段：

- **1.生产者发送消息到broker可靠性保证**

**第一种方案是事务机制** ：RabbitMQ提供事务消息，能确保生产者到broker不丢。在生产者发送消息之前，通过 `channel.txSelect` 开启一个事务，接着发送消息， 如果消息投递失败，进行事务回滚 `channel.txRollback`，然后重新发送， 如果收到消息，就提交事务 `channel.txCommit`
**但是这是同步操作，一条消息发送之后会使发送端阻塞** ，以等待broker的回应，之后才能继续发送下一条消息，生产者生产消息的吞吐量和性能都会大大降低

**第二种方式是请求确认机制** ：生产者通过调用 `channel.confirmSelect` 方法将信道设置为 `confirm` 模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数）

>其实Confirm模式有三种方式实现：
>
>串行confirm模式：producer每发送一条消息后，调用waitForConfirms()方法，等待broker端confirm，如果服务器端返回false或者在超时时间内未返回，客户端进行消息重传。
>批量confirm模式：producer每发送一批消息后，调用waitForConfirms()方法，等待broker端confirm。
>异步confirm模式：提供一个回调方法，broker confirm了一条或者多条消息后producer端会回调这个方法。
                  
**解决了上面的问题，下面还会遇到一个问题，消息丢失的另一个情况？就是交换器未匹配到队列**

这里有两个解决方案，

- 1. 使用 `mandatory` 设置true：通过调用 `channel.addReturnListener` 来添加监听器，只要发送的消息，没有路由到具体的队列，`ReturnListener` 就会收到监听消息
- 2. 利用备份交换机（alternate-exchange）：当你发送消息到你自己的exchange时候，对应key没有路由到queue，就会自动转移到 `alternate-exchange` 对应的queue，起码消息不会丢失


- **2.broker存储消息如何保证**

- 1. 消息持久化，持久化 `交换器channel(durable=true)`、`队列queue(durable=true)`、`消息message(deliveryMode(2))`
- 2. 集群部署，确保消息至少同步到2个硬盘节点

- **3.broker到消费者消息如何不丢**

消费端采用和发送端类似的机制，**请求确认** ，首先关闭自动确认，业务执行完成后手动ack，`channel.basicAck(deliveryTag, false)`

#### RabbitMQ消息是推的还是拉的？

`RabbitMQ` 支持推和拉两种模式：

- channel.basicConsume() ：会自动的不断地收到推的消息
- channel.basicGet：拉的模式需要消费者主动去拉取，实时性较差，也会增加不必要的消耗。（长轮询）


#### RabbitMQ如何集群部署？

在 RabbitMQ 集群中，节点类型可以分为两种：

- **内存节点：** 元数据存放于内存中。为了重启后能同步数据，内存节点会将磁盘节点的地址存放于磁盘之中，除此之外，如果消息被持久化了也会存放于磁盘之中，因为内存节点读写速度快，一般客户端会连接内存节点。
- **磁盘节点：** 元数据存放于磁盘中（默认节点类型），需要保证至少一个磁盘节点，否则一旦宕机，无法恢复数据，从而也就无法达到集群的高可用目的。

**普通集群模式**

在普通集群模式下，集群中各个节点之间只会相互同步元数据，也就是说，消息数据不会被同步。那么问题就来了，假如我们连接到 A 节点，但是消息又存储在 B 节点又怎么办呢？
不论是生产者还是消费者，假如连接到的节点上没有存储队列数据，那么内部会将其转发到存储队列数据的节点上进行存储。 **虽然说内部可以实现转发，但是因为消息仅仅只是存储在一个节点，那么假如这节点挂了，消息是不是就没有了？这个问题确实存在，所以这种普通集群模式并没有达到高可用的目的。**

**镜像队列模式**

镜像队列模式下，节点之间不仅仅会同步元数据，消息内容也会在镜像节点间同步，可用性更高。这种方案提升了可用性的同时，因为同步数据之间也会带来网络开销从而在一定程度上会影响到性能

在 `RabbitMQ` 集群中，通过 `Keepalived` 和 `HAProxy` 两个组件实现了集群的高可用性和负载均衡功能：

- `HAProxy` 实现了负载均衡
- 为了实现 HAProxy 的高可用，需要再引入一个 `Keepalived` 组件，`Keepalived` 组件主要有以下特性：具有负载功能，可以监控集群中的节点状态，如果集群中某一个节点宕机，可以实现故障转移