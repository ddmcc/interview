## 1,线程池四种拒绝策略
当任务源源不断的过来，而我们的系统又处理不过来的时候，我们要采取的策略是拒绝服务。
ThreadPoolExecutor类实现了ExecutorService接口和Executor接口，可以设置线程池corePoolSize，最大线程池大小，AliveTime，拒绝策略等
- CallerRunsPolicy：它直接在 execute 方法的调用线程中运行被拒绝的任务
这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。
（对某些应用场景来讲，很有可能造成当前线程也被阻塞。如果所有线程都是不能执行的，很可能导致程序没法继续跑了。需要视业务情景而定吧。）
- AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException 
这种策略直接抛出异常，丢弃任务。（jdk默认策略，队列满并线程满时直接拒绝添加新任务，并抛出异常，为了保证后续任务的正常进行，丢弃一些也是可以接收的，记得做好记录）
- DiscardPolicy：不能执行的任务将被删除 
这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。
- DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部（最旧）的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程） 
在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。

## 2,jvm调优

### 1,java内存模型，新生代老年代算法

### 2,新生代老年代属于堆还是栈，还知道哪些gc算法

### 3,创建大对象也是在新生代分配吗

### 4,新生代的算法

### 5,说说minor gc,minor gc触发条件

### 6,老年代用了什么算法

### 7,说说标记整理算法

### 8,full gc是否真正回收了废弃对象

### 9,有哪些gc策略。你觉得你的项目中如果需要jvm调优你会注重哪个分带的调优，或者说更注重哪种gc调优，为什么，具体怎么做

## 3,tomcat调优

## 4,sql左连接右连接区别
左连接返回左边所有记录和右边符合条件的记录
右连接返回右边所有记录和左边符合条件的记录

## 5,stringbuffer和stringbuild区别
StringBuffer 中大部分都是synchronized，同步方法，因此是线程安全的。
StringBuild 则没有，所以它不是线程安全的。
在单线程情况下，StringBuild效率更高，因为不是同步方法。

## 6,StringBuild线程不安全体现在哪
因为StringBuild的操作都是非同步的，而它的字符数组以及长度都是继承父类的全局变量
而且操作不具有原子性，所以就有可能发生线程不安全。

## 7,你对线程安不安全怎么理解（关键词:全局变量、JVM运行时数据区、可见性、原子性、锁
>线程安全问题都是由全局变量及静态变量引起的。

这是因为JVM运行时数据区包括了程序计数器，本地方法栈，jvm栈，堆。在这四个区中，前三个都是线程间隔离的。
只有堆内存是线程间共享的。而全局变量放在堆内存中，各线程内jvm栈只保存了对象引用，所以各线程更改的还是一个
内存地址的数据。
在JDK1.8中元数据区取代了永久代，元数据区并不在虚拟机中，而在本地内存中。静态变量是保存在元数据区中的。所以对于
线程来说，操作的还是同一内存地址上的数据。

>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；
>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

- 可见性问题：jvm有一个主内存，每个线程有自己的高速缓存，当运行时每个线程都会在自己的高速缓存中建立一个变量副本，
操作完后再把值写入到主内存。在多线程的情况下，有可能当线程A操作完，但值还未写入，这时线程B获取时间片在执行变量值还是未改变的。

**线程A改变了值，线程B没有立即看到线程A修改的值这就是可见性问题。**

- 原子性问题： **即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**
比如：size += 1 相当于 size = size + 1，这边就有两个操作了，先size+1，再把值赋给size。如果这两个操作不具备原子性，就会造成线程不安全。
在多线程情况下，有可能线程A刚做完size+1的操作，这时被线程B抢走了时间片，而B读到的就是错误的数据。

- 有序性问题： **即程序执行的顺序按照代码的先后顺序执行**  但是有时候并不是如此。

指令重排序： **源代码中的顺序与得到的字节码顺序不一样或者字节码顺序与实际的执行顺序不一样**
在编译的时候静态编译器会.java编译成.class，动态编译器jit会将.class编译成jvm执行的文件，在编译的时候还会对性能进行优化，
这时候就有可能改变了代码的顺序，即源代码和执行代码的顺序是不一致的。

#### 如何保证线程安全
- 上面说了线程安全是因为全局变量及静态变量引起的。所以把全局变量和静态变量改成局部变量就不会出现线程安全的问题。
因为局部变量的值保存在jvm栈内存里。
- 用同步锁（synchronized，Lock）可以解决原子性问题，因为线程间是互斥的，所以能保证原子性。
- 用同步锁还可以保证可见性问题，在synchronized关键字中，获得锁后会先清除工作内存的变量副本，然后从主内存拷贝变量的最新副本到线程工作内存，
执行代码，将更改后的最新的共享变量的值刷新到主内存，释放互斥锁。而Lock，在Java并发编程实战中,有句话是"线程A拿到lock对象对数据进行修改, 线程B拿到lock对象后,
对于线程A的修改线程B是可见的, 线程B可以看到线程A的所有操作结果"，也可以保证可见性。
volatile变量也可以保证该变量对所有线程可见，但不能保证原子性。
- 对于有序性synchronized和锁都可以保证，都保证了只有一个线程执行，即使重排序也不会影响结果。
- Atomic***即可以保证原子性，又可以保证可见性，底层是通过CAS和volatile实现的

#### 总结 
线程安全是因为全局变量及静态变量引起的，如果有全局变量或静态变量则要解决可见性，有序性，有序性问题。

## 8,arraylist和linkedlist区别
数据结构：ArrayList是顺序存储的数据结构，底层是数组，它的存储地址是连续的。
	  LinkedList是链表结构的线程表，地址不是连续的，它是双向链表，节点保存着对上下节点的引用。
效率：ArrayList随机查询的时间复杂度是O(1),LinkedList随机查询需要移动指针查询,复杂度为O(n)
直接添加复杂度都为O(1),但是ArrayList有可能触发扩容，需要将数组复制到新的数组。
指定位置添加ArrayList需要将添加索引后面的移动且有可能触发扩容,而LinkedList需要先查找添加位置的节点,
所以也是O(n),但是会先判断从首节点开始查询还是尾结点,当插入位置为中间时,所需时间最长。
删除操作ArrayList删除后需要移动后面的元素所以为O(n),LinkedList需要先遍历节点所以也为O(n).

## 9,spring ioc，aop作用,原理

## 10,hashmap原理

## 11,hashtable

## 12,concurrentHashMap

## 13,hashmap遍历

## 14,springmvc和struts区别

## 15,用过什么数据库，有没有做过数据库优化，什么情况下要用到索引，好处是什么，哪些字段适合建立索引，mysql索引底层数据结构了解吗

## 16,索引什么情况下会失效，联合索引abc只用了a字段，索引是否会生效

## 17,什么情况下要用到多线程，为什么要用，好处
在实际使用中，每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源，
甚至可能要比花在实际处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，
活动的线程也需要消耗系统资源。如果在一个JVM中创建太多的线程，可能会导致系统由于过度消耗内存或者“切换过度”而导致系统资源不足。
为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目，
尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务，
这就是“池化资源”技术产生的原因。

## 18,启动多个线程，如何知道他们都运行完毕了

## 19,string为什么是不可变的

## 20,重写重载

## 21,object类有哪些方法

## 22,sleep和wait区别

## 23,实现线程的方式

## 24,run，start区别

## 25,线程有几种状态

## 26,synchronize实现原理

## 27,与lock区别

## 28,还知道哪些锁，说说自旋锁

## 29,线程池等待队列

## 30,死锁产生原因

## 31,为什么java可以一次编译，到处运行

## 32,事务特性

## 33,mysql有哪些函数

## 34,http和https区别

## 35,get和post区别

## 36,springbean是单例吗,其中的单例bean是怎么实现的

## 37,redis有支持哪些数据结构

## 38,servlet怎么取前端参数

## 39,设计个洗牌算法

## 40,jdk中random实现原理，取随机种子

## 41,抽象类接口区别，接口中可以定义成员变量吗

## 42,接口中方法权限可以是private吗，接口是否可以写具体实现

## 43,sql交并集

## 44,事务隔离级别

## 45,能调用另一个类的私有方法吗，怎么做

## 46,如果线程池执行shutdown或shutdownNow，线程池中线程会中断吗，会出现什么异常，catch处理中该写些什么

## 47,用过哪些concurrent包下的类，说说原子类

## 48,cas操作可能会存在什么问题

## 49,dk中有哪些设计模式的运用，项目中用了哪些设计模式

## 50,treemap中compartor用了什么设计模式

## 51,有哪些单例模式的实现方式

## 52,注解实现原理

## 53,servlet和jsp区别

## 54,spirngmvc controller中定义全局hashmap，它是否是线程安全的，为什么

## 55,Io nio区别，nio原理

## 56,项目中用哪种方式解析xml的

## 57,servlet生命周期

## 58,tomcat在初始化中做了什么事

## 59,过滤器和拦截器的区别

## 60,oracle分页的sql关键字是什么
rownum  mysql：limit

## 61,分库分表按什么规则分,如果查询字段不是分库分表的规则字段，怎么办

## 62,jdbc连接步骤

## 63,statement和prepareStatement区别

## 64,项目中数据库事务控制你们是怎么做的

## 65,TreeMap,TreeSet,HashSet实现原理

## 66,dom4j怎么取节点

## 67,为什么重写equals方法最好也得重写hashcode

## 68,treeMap中元素怎么排序，如果没实现comparator接口会怎么样

## 69,序列化作用

## 70,你对hash的理解

## 71,hashSet是怎么去重的

## 72,socket长连接短连接，连接出现异常你是怎么处理的

## 73,mybatis分页

## 74,BIO,NIO,AIO区别

## 75,1.假如servlet处理一个请求需要0.4秒，那么处理100请求大概需要多久，为什么。同时处理1000个请求导致服务器压力过大崩溃怎么解决

## 76,线上系统造成服务器cpu占用率过高问题

## 77,Arraylist当前容量是10，且有9个数据，那么是添加第10个数据时扩容还是第11个

## 78,扩容怎么实现的，为什么采用复制数组的方式而不是往后直接添加数据

## 79,锁升级:偏向锁->轻量级锁->重量级锁

## 80, 线程池有哪些参数，各代表什么意思

## 81,jdk中提供了哪几种线程池的实现

## 82,线程池中提供哪些队列种

## 83,io中用了什么设计模式

## 84,jdk1.8 lambda说说它的闭包体现在哪

## 85,spring bean的生命周期

## 86,spring的BeanFactory和FactoryBean有什么区别
